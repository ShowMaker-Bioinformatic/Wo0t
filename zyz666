import streamlit as st
import pandas as pd
import numpy as np
import matplotlib as mpl  # æ–°å¢
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import joblib
import os
import time
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import mean_absolute_error, r2_score, mean_squared_error
import io
import base64
import tempfile
from datetime import datetime

# è®¾ç½®matplotlibä¸­æ–‡å­—ä½“æ”¯æŒ - è§£å†³å›¾è¡¨ä¸­æ–‡æ˜¾ç¤ºæ–¹æ¡†é—®é¢˜
def set_chinese_font():
    try:
        # Windowså¸¸ç”¨ä¸­æ–‡å­—ä½“
        font_names = [
            'SimHei',   # é»‘ä½“
            'Microsoft YaHei', # å¾®è½¯é›…é»‘
            'KaiTi',    # æ¥·ä½“
            'FangSong', # ä»¿å®‹
            'STSong',   # åæ–‡å®‹ä½“
            'STKaiti',  # åæ–‡æ¥·ä½“
            'LiHei Pro' # è‹¹æœä¸½é»‘ (Mac)
        ]
        
        # æ£€æŸ¥ç³»ç»Ÿå¯ç”¨å­—ä½“
        available_fonts = [font.name for font in mpl.font_manager.fontManager.ttflist]
        
        # å¯»æ‰¾ç¬¬ä¸€ä¸ªå¯ç”¨çš„ä¸­æ–‡å­—ä½“
        for font_name in font_names:
            if font_name in available_fonts:
                mpl.rcParams['font.sans-serif'] = [font_name]
                mpl.rcParams['axes.unicode_minus'] = False  # è§£å†³è´Ÿå·æ˜¾ç¤ºé—®é¢˜
                print(f"æˆåŠŸè®¾ç½®ä¸­æ–‡å­—ä½“: {font_name}")
                return True
        
        # å¦‚æœæœªæ‰¾åˆ°æŒ‡å®šä¸­æ–‡å­—ä½“ï¼Œå°è¯•ä½¿ç”¨é»˜è®¤è®¾ç½®
        mpl.rcParams['font.sans-serif'] = ['sans-serif']
        print("æœªæ‰¾åˆ°ç³»ç»Ÿä¸­æ–‡å­—ä½“ï¼Œä½¿ç”¨é»˜è®¤å­—ä½“")
        return False
    
    except Exception as e:
        print(f"è®¾ç½®ä¸­æ–‡å­—ä½“æ—¶å‡ºé”™: {str(e)}")
        return False

# æ‰§è¡Œå­—ä½“è®¾ç½®
set_chinese_font()

# è®¾ç½®é¡µé¢é…ç½®
st.set_page_config(
    page_title="ç»“ç›´è‚ ç™Œç”Ÿå­˜æ—¶é—´é¢„æµ‹å¹³å°",
    page_icon="â³",
    layout="wide",
    initial_sidebar_state="expanded"
)

# è‡ªå®šä¹‰CSSæ ·å¼
st.markdown("""
    <style>
    /* ä¿æŒåŸæœ‰CSSä¸å˜ */
    .header-style {
        font-size: 20px;
        font-weight: bold;
        color: #2c3e50;
    }
    .highlight {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 10px;
    }
    .risk-high {
        background-color: #ffcccc;
        padding: 10px;
        border-radius: 5px;
    }
    .risk-low {
        background-color: #ccffcc;
        padding: 10px;
        border-radius: 5px;
    }
    .sidebar-section {
        margin-bottom: 20px;
    }
    .st-bd {
        padding: 10px;
        border: 1px solid #e1e4e8;
        border-radius: 5px;
    }
    .feature-importance {
        max-height: 400px;
        overflow-y: auto;
    }
    .prediction-result {
        background-color: #e6f7ff;
        padding: 15px;
        border-radius: 5px;
        margin-top: 15px;
    }
    .metric-card {
        background-color: #f0f2f6;
        border-radius: 10px;
        padding: 15px;
        margin-bottom: 15px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .tab-content {
        padding: 20px;
        border: 1px solid #e1e4e8;
        border-radius: 10px;
        margin-top: 15px;
    }
    /* æ–°å¢ï¼šè¡¨æ ¼ä¸­æ–‡å­—ä½“ */
    .stDataFrame table {
        font-family: 'Microsoft YaHei', 'SimHei', sans-serif !important;
    }
    </style>
""", unsafe_allow_html=True)

# ======================
# æ•°æ®å¤„ç†ä¸æ¨¡å‹è®­ç»ƒ
# ======================
def generate_sample_data():
    """ç”Ÿæˆç»“ç›´è‚ ç™Œç¤ºä¾‹æ•°æ®é›†"""
    np.random.seed(42)
    size = 500  # ä¸­ç­‰å¤§å°çš„æ•°æ®é›†
    
    # åˆ›å»ºåŸºç¡€ç‰¹å¾
    df = pd.DataFrame({
        'æ‚£è€…ID': range(1, size+1),
        'ç™»è®°æ—¥æœŸ': [datetime.now().strftime("%Y-%m-%d") for _ in range(size)],
        'å¹´é¾„': np.random.randint(30, 85, size),
        'æ€§åˆ«': np.random.choice(['ç”·', 'å¥³'], size, p=[0.55, 0.45]),
        'TNMåˆ†æœŸ': np.random.choice(['I', 'II', 'III', 'IV'], size, p=[0.15, 0.3, 0.4, 0.15]),
        'CEAæ°´å¹³(ng/mL)': np.round(np.random.uniform(0.5, 100, size), 1),
        'MSIçŠ¶æ€': np.random.choice(['MSS', 'MSI-L', 'MSI-H'], size, p=[0.7, 0.2, 0.1]),
        'KRASçªå˜': np.random.choice(['é˜³æ€§', 'é˜´æ€§'], size, p=[0.45, 0.55]),
        'BRAFçªå˜': np.random.choice(['é˜³æ€§', 'é˜´æ€§'], size, p=[0.15, 0.85]),
        'è‚¿ç˜¤ä½ç½®': np.random.choice(['å‡ç»“è‚ ', 'æ¨ªç»“è‚ ', 'é™ç»“è‚ ', 'ä¹™çŠ¶ç»“è‚ ', 'ç›´è‚ '], size),
        'æ²»ç–—æ–¹æ¡ˆ': np.random.choice(['FOLFOX', 'CAPOX', 'FOLFIRI', 'å…ç–«æ²»ç–—'], size),
        'æ²»ç–—å“åº”': np.random.choice(['å®Œå…¨ç¼“è§£', 'éƒ¨åˆ†ç¼“è§£', 'ç–¾ç—…ç¨³å®š', 'ç–¾ç—…è¿›å±•'], size),
        'ç”Ÿå­˜çŠ¶æ€': np.random.choice(['å­˜æ´»', 'æ­»äº¡'], size, p=[0.65, 0.35]),
        'ç”Ÿå­˜æ—¶é—´(æœˆ)': np.random.exponential(24, size).astype(int) + np.random.randint(0, 60, size)
    })
    
    # æ·»åŠ ç”Ÿå­˜æ—¶é—´ä¸ç‰¹å¾çš„ç›¸å…³æ€§
    df.loc[df['TNMåˆ†æœŸ'] == 'I', 'ç”Ÿå­˜æ—¶é—´(æœˆ)'] += np.random.randint(24, 60, len(df[df['TNMåˆ†æœŸ'] == 'I']))
    df.loc[df['TNMåˆ†æœŸ'] == 'II', 'ç”Ÿå­˜æ—¶é—´(æœˆ)'] += np.random.randint(12, 36, len(df[df['TNMåˆ†æœŸ'] == 'II']))
    df.loc[df['TNMåˆ†æœŸ'] == 'III', 'ç”Ÿå­˜æ—¶é—´(æœˆ)'] += np.random.randint(6, 24, len(df[df['TNMåˆ†æœŸ'] == 'III']))
    df.loc[df['TNMåˆ†æœŸ'] == 'IV', 'ç”Ÿå­˜æ—¶é—´(æœˆ)'] += np.random.randint(0, 12, len(df[df['TNMåˆ†æœŸ'] == 'IV']))
    
    df.loc[df['MSIçŠ¶æ€'] == 'MSI-H', 'ç”Ÿå­˜æ—¶é—´(æœˆ)'] += np.random.randint(12, 36, len(df[df['MSIçŠ¶æ€'] == 'MSI-H']))
    
    return df

class SurvivalTimeModel:
    """ç”Ÿå­˜æ—¶é—´é¢„æµ‹æ¨¡å‹"""
    def __init__(self):
        self.model = None
        self.scaler = None
        self.encoders = {}
        self.features = ['å¹´é¾„', 'æ€§åˆ«', 'TNMåˆ†æœŸ', 'CEAæ°´å¹³(ng/mL)', 'MSIçŠ¶æ€', 'KRASçªå˜']
        self.target = 'ç”Ÿå­˜æ—¶é—´(æœˆ)'
        self.trained = False
        self.train_metrics = {}
        self.category_mapping = {
            'æ€§åˆ«': {'ç”·': 0, 'å¥³': 1, 'male': 0, 'female': 1},
            'TNMåˆ†æœŸ': {'I': 0, 'II': 1, 'III': 2, 'IV': 3},
            'MSIçŠ¶æ€': {'MSS': 0, 'MSI-L': 1, 'MSI-H': 2},
            'KRASçªå˜': {'é˜³æ€§': 1, 'é˜´æ€§': 0, 'positive': 1, 'negative': 0}
        }
    
    def preprocess_data(self, df):
        """æ•°æ®é¢„å¤„ç†ï¼ˆç¡®ä¿å…¼å®¹æ€§ï¼‰"""
        processed = df.copy()
        
        # å¤„ç†ç¼ºå¤±å€¼
        for col in self.features + [self.target]:
            if col in processed.columns and processed[col].isnull().any():
                if processed[col].dtype == 'object':
                    processed[col].fillna('æœªçŸ¥', inplace=True)
                else:
                    processed[col].fillna(processed[col].median(), inplace=True)
        
        # ç»Ÿä¸€TNMåˆ†æœŸæ ¼å¼
        if 'TNMåˆ†æœŸ' in processed.columns:
            processed['TNMåˆ†æœŸ'] = processed['TNMåˆ†æœŸ'].str.replace('Stage', '').str.strip()
            processed['TNMåˆ†æœŸ'] = processed['TNMåˆ†æœŸ'].str.replace('--', 'æœªçŸ¥')
        
        # è½¬æ¢åˆ†ç±»å˜é‡ä¸ºæ•°å€¼
        for col in ['æ€§åˆ«', 'TNMåˆ†æœŸ', 'MSIçŠ¶æ€', 'KRASçªå˜']:
            if col in processed.columns:
                # ä½¿ç”¨ç»Ÿä¸€çš„æ˜ å°„è½¬æ¢
                processed[col] = processed[col].map(self.category_mapping[col]).fillna(-1)
        
        # æ ‡å‡†åŒ–æ•°å€¼ç‰¹å¾
        numeric_cols = ['å¹´é¾„', 'CEAæ°´å¹³(ng/mL)']
        if self.scaler is None:
            self.scaler = StandardScaler()
            self.scaler.fit(processed[numeric_cols])
        processed[numeric_cols] = self.scaler.transform(processed[numeric_cols])
        
        return processed[self.features], processed[self.target] if self.target in processed.columns else None
    
    def train(self, df):
        """è®­ç»ƒæ¨¡å‹ï¼ˆåŒ…å«é”™è¯¯å¤„ç†ï¼‰"""
        try:
            X, y = self.preprocess_data(df)
            
            # æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„æ•°æ®
            if len(y) < 10:
                return False, "é”™è¯¯ï¼šæ•°æ®é‡ä¸è¶³ï¼Œéœ€è¦è‡³å°‘10ä¸ªæ ·æœ¬"
            
            # åˆ’åˆ†è®­ç»ƒæµ‹è¯•é›†
            X_train, X_test, y_train, y_test = train_test_split(
                X, y, test_size=0.2, random_state=42
            )
            
            # è®­ç»ƒéšæœºæ£®æ—å›å½’æ¨¡å‹
            self.model = RandomForestRegressor(
                n_estimators=100,  # é€‚åº¦å¤§å°
                max_depth=5,      # é˜²æ­¢è¿‡æ‹Ÿåˆ
                random_state=42,
                n_jobs=-1
            )
            self.model.fit(X_train, y_train)
            
            # è¯„ä¼°æ¨¡å‹
            y_pred = self.model.predict(X_test)
            
            # è®¡ç®—è¯„ä¼°æŒ‡æ ‡
            mae = mean_absolute_error(y_test, y_pred)
            r2 = r2_score(y_test, y_pred)
            rmse = np.sqrt(mean_squared_error(y_test, y_pred))
            
            # ä¿å­˜è¯„ä¼°æŒ‡æ ‡
            self.train_metrics = {
                'mae': mae,
                'r2': r2,
                'rmse': rmse,
                'y_test': y_test,
                'y_pred': y_pred
            }
            
            self.trained = True
            return True, f"æ¨¡å‹è®­ç»ƒæˆåŠŸï¼MAE: {mae:.1f}ä¸ªæœˆ, RÂ²: {r2:.2f}"
        except Exception as e:
            return False, f"è®­ç»ƒè¿‡ç¨‹ä¸­å‡ºé”™: {str(e)}"
    
    def predict(self, patient_data):
        """é¢„æµ‹å•ä¸ªæ‚£è€…ç”Ÿå­˜æ—¶é—´ï¼ˆå¥å£®ç‰ˆï¼‰"""
        if not self.trained or self.model is None:
            return None, "æ¨¡å‹å°šæœªè®­ç»ƒ"
        
        try:
            # è½¬æ¢ä¸ºDataFrame
            patient_df = pd.DataFrame([patient_data])
            
            # åº”ç”¨ç›¸åŒçš„é¢„å¤„ç†
            for col in ['æ€§åˆ«', 'TNMåˆ†æœŸ', 'MSIçŠ¶æ€', 'KRASçªå˜']:
                if col in patient_df.columns:
                    # ä½¿ç”¨ç»Ÿä¸€çš„æ˜ å°„è½¬æ¢
                    patient_df[col] = patient_df[col].map(self.category_mapping[col]).fillna(-1)
            
            # æ ‡å‡†åŒ–æ•°å€¼ç‰¹å¾
            numeric_cols = ['å¹´é¾„', 'CEAæ°´å¹³(ng/mL)']
            if self.scaler:
                patient_df[numeric_cols] = self.scaler.transform(patient_df[numeric_cols])
            
            # é¢„æµ‹
            prediction = self.model.predict(patient_df[self.features])[0]
            
            return prediction, "é¢„æµ‹æˆåŠŸ"
        except Exception as e:
            return None, f"é¢„æµ‹æ—¶å‡ºé”™: {str(e)}"

# ======================
# å¯è§†åŒ–å‡½æ•°
# ======================
def plot_survival_curve(df):
    """ç»˜åˆ¶ç”Ÿå­˜æ›²çº¿"""
    if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' not in df.columns or 'ç”Ÿå­˜çŠ¶æ€' not in df.columns:
        return plt.figure()
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # æŒ‰TNMåˆ†æœŸåˆ†ç»„
    for stage in sorted(df['TNMåˆ†æœŸ'].dropna().unique(), key=lambda x: str(x)):
        stage_df = df[df['TNMåˆ†æœŸ'] == stage]
        if len(stage_df) == 0:
            continue
        survival_data = []
        max_time = min(120, df['ç”Ÿå­˜æ—¶é—´(æœˆ)'].max())  # é™åˆ¶æœ€å¤§æ—¶é—´
        for t in range(0, int(max_time)+10, 10):
            survived = ((stage_df['ç”Ÿå­˜æ—¶é—´(æœˆ)'] >= t) & (stage_df['ç”Ÿå­˜çŠ¶æ€'] == 'å­˜æ´»')).mean()
            survival_data.append((t, survived))
        
        times, probs = zip(*survival_data)
        ax.plot(times, probs, label=f'{stage}æœŸ', linewidth=2)
    
    # ä½¿ç”¨ä¸­æ–‡å­—ä½“
    ax.set_title('ä¸åŒTNMåˆ†æœŸæ‚£è€…çš„ç”Ÿå­˜æ›²çº¿')
    ax.set_xlabel('æ—¶é—´ (æœˆ)')
    ax.set_ylabel('ç”Ÿå­˜ç‡')
    ax.legend(title='TNMåˆ†æœŸ', prop={'family': 'SimHei'})
    ax.grid(True)
    return fig

def plot_feature_distribution(df, feature):
    """ç»˜åˆ¶ç‰¹å¾åˆ†å¸ƒå›¾"""
    if feature not in df.columns:
        return plt.figure()
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    if df[feature].dtype == 'object':
        # åˆ†ç±»å˜é‡
        value_counts = df[feature].value_counts()
        sns.barplot(x=value_counts.index, y=value_counts.values, ax=ax)
        # ä½¿ç”¨ä¸­æ–‡å­—ä½“
        ax.set_title(f'{feature}åˆ†å¸ƒ')
        ax.set_xlabel(feature)
        ax.set_ylabel('è®¡æ•°')
        plt.xticks(rotation=45)
    else:
        # æ•°å€¼å˜é‡
        sns.histplot(df[feature], kde=True, ax=ax)
        # ä½¿ç”¨ä¸­æ–‡å­—ä½“
        ax.set_title(f'{feature}åˆ†å¸ƒ')
        ax.set_xlabel(feature)
        ax.set_ylabel('é¢‘ç‡')
    
    # è®¾ç½®å­—ä½“
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] +
                 ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontproperties('SimHei')  # ä½¿ç”¨å·²è®¾ç½®çš„ä¸­æ–‡å­—ä½“
    
    return fig

def plot_feature_correlation(df, feature1, feature2):
    """ç»˜åˆ¶ä¸¤ä¸ªç‰¹å¾çš„ç›¸å…³æ€§"""
    if feature1 not in df.columns or feature2 not in df.columns:
        return plt.figure()
    
    fig, ax = plt.subplots(figsize=(10, 6))
    
    if df[feature1].dtype == 'object' or df[feature2].dtype == 'object':
        # è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯åˆ†ç±»å˜é‡
        sns.boxplot(x=feature1, y=feature2, data=df, ax=ax)
        # ä½¿ç”¨ä¸­æ–‡å­—ä½“
        ax.set_title(f'{feature1} vs {feature2}')
    else:
        # ä¸¤ä¸ªéƒ½æ˜¯æ•°å€¼å˜é‡
        sns.scatterplot(x=feature1, y=feature2, data=df, alpha=0.6, ax=ax)
        # ä½¿ç”¨ä¸­æ–‡å­—ä½“
        ax.set_title(f'{feature1} vs {feature2} æ•£ç‚¹å›¾')
    
    # è®¾ç½®å­—ä½“
    ax.set_xlabel(feature1)
    ax.set_ylabel(feature2)
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] +
                 ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontproperties('SimHei')  # ä½¿ç”¨å·²è®¾ç½®çš„ä¸­æ–‡å­—ä½“
    
    plt.xticks(rotation=45)
    return fig

def plot_prediction_vs_actual(y_test, y_pred):
    """ç»˜åˆ¶é¢„æµ‹å€¼ vs å®é™…å€¼"""
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.scatter(y_test, y_pred, alpha=0.6)
    ax.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2)
    
    # ä½¿ç”¨ä¸­æ–‡å­—ä½“
    ax.set_xlabel('å®é™…ç”Ÿå­˜æ—¶é—´ (æœˆ)')
    ax.set_ylabel('é¢„æµ‹ç”Ÿå­˜æ—¶é—´ (æœˆ)')
    ax.set_title('é¢„æµ‹å€¼ vs å®é™…å€¼')
    
    # è®¾ç½®å­—ä½“
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label]):
        item.set_fontproperties('SimHei')
    
    return fig

def plot_residuals(y_test, y_pred):
    """ç»˜åˆ¶æ®‹å·®å›¾"""
    residuals = y_test - y_pred
    fig, ax = plt.subplots(figsize=(8, 6))
    ax.scatter(y_pred, residuals, alpha=0.6)
    ax.axhline(y=0, color='r', linestyle='-')
    
    # ä½¿ç”¨ä¸­æ–‡å­—ä½“
    ax.set_xlabel('é¢„æµ‹ç”Ÿå­˜æ—¶é—´ (æœˆ)')
    ax.set_ylabel('æ®‹å·®')
    ax.set_title('æ®‹å·®åˆ†æ')
    
    # è®¾ç½®å­—ä½“
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label]):
        item.set_fontproperties('SimHei')
    
    return fig

def plot_feature_importance(model, feature_names):
    """ç»˜åˆ¶ç‰¹å¾é‡è¦æ€§"""
    if model.model is None:
        return plt.figure()
    
    try:
        importances = model.model.feature_importances_
        indices = np.argsort(importances)[::-1]
        
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # ä½¿ç”¨ä¸­æ–‡å­—ä½“
        ax.set_title("ç‰¹å¾é‡è¦æ€§")
        ax.set_xlabel("ç‰¹å¾")
        ax.set_ylabel("é‡è¦æ€§")
        
        # åˆ›å»ºæ¡å½¢å›¾
        bars = ax.bar(range(len(importances)), importances[indices], align="center")
        ax.set_xticks(range(len(importances)))
        
        # è®¾ç½®ç‰¹å¾åç§°
        ax.set_xticklabels([feature_names[i] for i in indices], rotation=45)
        
        # è®¾ç½®å­—ä½“
        for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + 
                     ax.get_xticklabels() + ax.get_yticklabels()):
            item.set_fontproperties('SimHei')
        
        return fig
    except Exception:
        return plt.figure()

# ======================
# æ•°æ®æ¢ç´¢åˆ†æ
# ======================
def perform_eda(df):
    """æ‰§è¡Œæ¢ç´¢æ€§æ•°æ®åˆ†æ"""
    eda_results = {}
    
    # åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯
    eda_results['shape'] = df.shape
    eda_results['dtypes'] = df.dtypes
    eda_results['describe'] = df.describe(include='all')
    
    # ç¼ºå¤±å€¼åˆ†æ
    eda_results['missing_values'] = df.isnull().sum()
    
    # ç›®æ ‡å˜é‡åˆ†å¸ƒ
    if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' in df.columns:
        eda_results['target_distribution'] = df['ç”Ÿå­˜æ—¶é—´(æœˆ)'].describe()
    
    return eda_results

# ======================
# Streamlitåº”ç”¨ç•Œé¢
# ======================
def main():
    st.title("â³ ç»“ç›´è‚ ç™Œç”Ÿå­˜æ—¶é—´é¢„æµ‹å¹³å°")
    st.markdown("> åŸºäºå¤šç»´åº¦ä¸´åºŠæ•°æ®çš„ç”Ÿå­˜æ—¶é—´é¢„æµ‹å·¥å…·")
    
    # åˆå§‹åŒ–ä¼šè¯çŠ¶æ€
    if 'survival_model' not in st.session_state:
        st.session_state.survival_model = SurvivalTimeModel()
    if 'df' not in st.session_state:
        st.session_state.df = generate_sample_data()
    
    # ä¾§è¾¹æ æ§åˆ¶é¢æ¿
    with st.sidebar:
        st.header("ğŸ“‚ æ•°æ®ç®¡ç†")
        
        # æ•°æ®æºé€‰æ‹©
        data_source = st.radio("é€‰æ‹©æ•°æ®æº", ["ç¤ºä¾‹æ•°æ®", "ä¸Šä¼ CSVæ–‡ä»¶"])
        
        if data_source == "ä¸Šä¼ CSVæ–‡ä»¶":
            uploaded_file = st.file_uploader("ä¸Šä¼ ç»“ç›´è‚ ç™Œæ•°æ®é›†", type="csv")
            if uploaded_file:
                df = pd.read_csv(uploaded_file)
                # ç¡®ä¿ç”Ÿå­˜æ—¶é—´åˆ—å­˜åœ¨
                if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' not in df.columns:
                    st.warning("æ•°æ®ä¸­ç¼ºå°‘'ç”Ÿå­˜æ—¶é—´(æœˆ)'åˆ—ï¼Œå°†ä½¿ç”¨ç¤ºä¾‹æ•°æ®")
                    st.session_state.df = generate_sample_data()
                else:
                    # ç¡®ä¿åŒ…å«æ‰€æœ‰å¿…è¦ç‰¹å¾
                    required_features = ['å¹´é¾„', 'æ€§åˆ«', 'TNMåˆ†æœŸ', 'CEAæ°´å¹³(ng/mL)', 'MSIçŠ¶æ€', 'KRASçªå˜']
                    missing_features = [feat for feat in required_features if feat not in df.columns]
                    
                    if missing_features:
                        st.warning(f"æ•°æ®ä¸­ç¼ºå°‘ä»¥ä¸‹ç‰¹å¾: {', '.join(missing_features)}ï¼Œå°†ä½¿ç”¨ç¤ºä¾‹æ•°æ®")
                        st.session_state.df = generate_sample_data()
                    else:
                        st.session_state.df = df
                        st.success("æ•°æ®ä¸Šä¼ æˆåŠŸï¼")
            else:
                st.info("è¯·ä¸Šä¼ CSVæ–‡ä»¶")
        else:
            dataset_size = st.slider("æ•°æ®é›†å¤§å°", 100, 1000, 500, step=100)
            st.session_state.df = generate_sample_data()
            st.info(f"å·²åŠ è½½ç¤ºä¾‹æ•°æ® ({dataset_size}è¡Œ)")
        
        df = st.session_state.df
        
        # æ•°æ®ç­›é€‰
        st.header("ğŸ” æ•°æ®ç­›é€‰")
        
        if 'TNMåˆ†æœŸ' in df.columns:
            tnm_options = df['TNMåˆ†æœŸ'].dropna().unique()
            if len(tnm_options) > 0:
                selected_stages = st.multiselect("TNMåˆ†æœŸç­›é€‰", tnm_options, tnm_options[:min(2, len(tnm_options))])
            else:
                selected_stages = []
                st.warning("TNMåˆ†æœŸæ•°æ®ä¸è¶³")
        else:
            selected_stages = []
            st.warning("æ•°æ®ä¸­ç¼ºå°‘TNMåˆ†æœŸ")
        
        if 'MSIçŠ¶æ€' in df.columns:
            msi_options = list(df['MSIçŠ¶æ€'].dropna().unique()) + ['å…¨éƒ¨']
            msi_filter = st.selectbox("MSIçŠ¶æ€ç­›é€‰", msi_options, index=len(msi_options)-1)
        else:
            msi_filter = 'å…¨éƒ¨'
            st.warning("æ•°æ®ä¸­ç¼ºå°‘MSIçŠ¶æ€")
        
        if 'å¹´é¾„' in df.columns:
            age_min, age_max = int(df['å¹´é¾„'].min()), int(df['å¹´é¾„'].max())
            if age_min < age_max:
                age_range = st.slider("å¹´é¾„èŒƒå›´", age_min, age_max, (max(50, age_min), min(70, age_max)))
            else:
                age_range = (50, 70)
                st.warning("å¹´é¾„æ•°æ®å¼‚å¸¸ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
        else:
            age_range = (50, 70)
            st.warning("æ•°æ®ä¸­ç¼ºå°‘å¹´é¾„ä¿¡æ¯")
        
        # æ¨¡å‹è®­ç»ƒ
        st.header("ğŸ¤– æœºå™¨å­¦ä¹ æ¨¡å‹")
        if st.button("è®­ç»ƒç”Ÿå­˜æ—¶é—´é¢„æµ‹æ¨¡å‹", key='train_btn'):
            with st.spinner("è®­ç»ƒæ¨¡å‹ä¸­..."):
                # ä½¿ç”¨æ­£ç¡®çš„æ¨¡å‹åç§°
                success, message = st.session_state.survival_model.train(st.session_state.df)
                if success:
                    st.success(message)
                    st.info(f"æ¨¡å‹è¯„ä¼°ç»“æœï¼šMAE {st.session_state.survival_model.train_metrics['mae']:.1f}ä¸ªæœˆ, RÂ² {st.session_state.survival_model.train_metrics['r2']:.2f}")
                else:
                    st.error(message)
        
        # æ¨¡å‹ä¿å­˜ä¸åŠ è½½
        st.header("ğŸ’¾ æ¨¡å‹ç®¡ç†")
        if st.session_state.survival_model.trained:
            if st.button("ä¿å­˜æ¨¡å‹"):
                model_path = os.path.join(tempfile.gettempdir(), "crc_survival_model.joblib")
                joblib.dump(st.session_state.survival_model, model_path)
                st.success(f"æ¨¡å‹å·²ä¿å­˜åˆ°: {model_path}")
        
        uploaded_model = st.file_uploader("ä¸Šä¼ è®­ç»ƒå¥½çš„æ¨¡å‹", type="joblib")
        if uploaded_model:
            try:
                st.session_state.survival_model = joblib.load(uploaded_model)
                st.success("æ¨¡å‹åŠ è½½æˆåŠŸï¼")
            except Exception as e:
                st.error(f"æ¨¡å‹åŠ è½½å¤±è´¥: {str(e)}")
    
    # ä¸»å†…å®¹åŒºåŸŸ
    df = st.session_state.df
    
    # æ˜¾ç¤ºæ•°æ®æ‘˜è¦
    st.subheader("ğŸ“‹ å½“å‰æ•°æ®é›†æ‘˜è¦")
    st.write(f"æ•°æ®é›†å¤§å°: {df.shape[0]} è¡Œ, {df.shape[1]} åˆ—")
    
    # åº”ç”¨ç­›é€‰æ¡ä»¶
    filtered_df = df.copy()
    if 'TNMåˆ†æœŸ' in filtered_df.columns and len(selected_stages) > 0:
        filtered_df = filtered_df[filtered_df['TNMåˆ†æœŸ'].isin(selected_stages)]
    if msi_filter != 'å…¨éƒ¨' and 'MSIçŠ¶æ€' in filtered_df.columns:
        filtered_df = filtered_df[filtered_df['MSIçŠ¶æ€'] == msi_filter]
    if 'å¹´é¾„' in filtered_df.columns:
        filtered_df = filtered_df[
            (filtered_df['å¹´é¾„'] >= age_range[0]) & 
            (filtered_df['å¹´é¾„'] <= age_range[1])
        ]
    
    # ======================
    # æ•°æ®æ¢ç´¢åˆ†æéƒ¨åˆ†
    # ======================
    st.header("ğŸ” æ•°æ®æ¢ç´¢åˆ†æ")
    
    with st.expander("æ•°æ®é›†æ¦‚è§ˆ"):
        st.subheader("åŸºæœ¬ç»Ÿè®¡ä¿¡æ¯")
        
        col1, col2 = st.columns(2)
        with col1:
            st.write("æ•°æ®ç±»å‹åˆ†å¸ƒ:")
            st.write(df.dtypes.value_counts().to_frame().rename(columns={0: 'è®¡æ•°'}))
        
        with col2:
            if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' in df.columns:
                st.write("ç”Ÿå­˜æ—¶é—´åˆ†å¸ƒ:")
                fig = px.histogram(df, x='ç”Ÿå­˜æ—¶é—´(æœˆ)', nbins=30)
                st.plotly_chart(fig, use_container_width=True)
    
    with st.expander("ç¼ºå¤±å€¼åˆ†æ"):
        missing_values = df.isnull().sum()
        missing_values = missing_values[missing_values > 0]
        if len(missing_values) > 0:
            st.write("ç¼ºå¤±å€¼ç»Ÿè®¡:")
            st.bar_chart(missing_values)
        else:
            st.success("æ•°æ®ä¸­æ²¡æœ‰ç¼ºå¤±å€¼")
    
    with st.expander("ç‰¹å¾åˆ†å¸ƒåˆ†æ"):
        col1, col2 = st.columns(2)
        with col1:
            feature1 = st.selectbox("é€‰æ‹©ç¬¬ä¸€ä¸ªç‰¹å¾", df.columns, index=0)
            fig1 = plot_feature_distribution(df, feature1)
            st.pyplot(fig1)
        
        with col2:
            feature2 = st.selectbox("é€‰æ‹©ç¬¬äºŒä¸ªç‰¹å¾", df.columns, index=1)
            fig2 = plot_feature_distribution(df, feature2)
            st.pyplot(fig2)
    
    with st.expander("ç‰¹å¾ç›¸å…³æ€§åˆ†æ"):
        col1, col2 = st.columns(2)
        with col1:
            corr_feature1 = st.selectbox("é€‰æ‹©ç‰¹å¾1", df.columns, index=0)
        with col2:
            corr_feature2 = st.selectbox("é€‰æ‹©ç‰¹å¾2", df.columns, index=1)
        
        fig_corr = plot_feature_correlation(df, corr_feature1, corr_feature2)
        st.pyplot(fig_corr)
    
    # ======================
    # æ•°æ®æ¦‚è§ˆéƒ¨åˆ†
    # ======================
    st.header("ğŸ“Š æ•°æ®é›†æ¦‚è§ˆ")
    
    col1, col2, col3, col4 = st.columns(4)
    col1.metric("æ€»ç—…ä¾‹æ•°", len(df))
    col2.metric("ç­›é€‰åç—…ä¾‹", len(filtered_df))
    
    if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' in df.columns:
        avg_survival = filtered_df['ç”Ÿå­˜æ—¶é—´(æœˆ)'].mean()
        col3.metric("å¹³å‡ç”Ÿå­˜æ—¶é—´", f"{avg_survival:.1f} ä¸ªæœˆ")
    
    if 'CEAæ°´å¹³(ng/mL)' in df.columns:
        avg_cea = filtered_df['CEAæ°´å¹³(ng/mL)'].mean()
        col4.metric("å¹³å‡CEAæ°´å¹³", f"{avg_cea:.1f} ng/mL")
    
    # æ•°æ®è¡¨æ ¼
    st.subheader("ğŸ“‹ ä¸´åºŠæ•°æ®è¯¦æƒ…")
    st.dataframe(filtered_df.head(50), height=300, use_container_width=True)
    
    # ======================
    # é«˜çº§å¯è§†åŒ–éƒ¨åˆ†
    # ======================
    st.header("ğŸ“ˆ é«˜çº§å¯è§†åŒ–åˆ†æ")
    
    tab1, tab2, tab3 = st.tabs(["ç”Ÿå­˜åˆ†æ", "ç‰¹å¾å…³ç³»", "æ¨¡å‹è¯„ä¼°"])
    
    with tab1:
        st.subheader("ç”Ÿå­˜åˆ†æ")
        if 'ç”Ÿå­˜æ—¶é—´(æœˆ)' in filtered_df.columns and 'ç”Ÿå­˜çŠ¶æ€' in filtered_df.columns:
            fig_survival = plot_survival_curve(filtered_df)
            st.pyplot(fig_survival)
        else:
            st.warning("ç¼ºå°‘ç”Ÿå­˜åˆ†ææ‰€éœ€æ•°æ®")
    
    with tab2:
        st.subheader("ç‰¹å¾å…³ç³»åˆ†æ")
        col1, col2 = st.columns(2)
        with col1:
            x_feature = st.selectbox("Xè½´ç‰¹å¾", df.columns, index=0, key='x_feature')
        with col2:
            y_feature = st.selectbox("Yè½´ç‰¹å¾", df.columns, index=1, key='y_feature')
        
        if x_feature and y_feature:
            fig_rel = plot_feature_correlation(filtered_df, x_feature, y_feature)
            st.pyplot(fig_rel)
    
    with tab3:
        st.subheader("æ¨¡å‹è¯„ä¼°")
        if st.session_state.survival_model.trained:
            # é¢„æµ‹å€¼ vs å®é™…å€¼
            st.write("### é¢„æµ‹å€¼ vs å®é™…å€¼")
            y_test = st.session_state.survival_model.train_metrics.get('y_test', None)
            y_pred = st.session_state.survival_model.train_metrics.get('y_pred', None)
            if y_test is not None and y_pred is not None:
                fig_pred = plot_prediction_vs_actual(y_test, y_pred)
                st.pyplot(fig_pred)
            
            # æ®‹å·®å›¾
            st.write("### æ®‹å·®åˆ†æ")
            if y_test is not None and y_pred is not None:
                fig_res = plot_residuals(y_test, y_pred)
                st.pyplot(fig_res)
            
            # ç‰¹å¾é‡è¦æ€§
            st.write("### ç‰¹å¾é‡è¦æ€§")
            fig_imp = plot_feature_importance(st.session_state.survival_model, st.session_state.survival_model.features)
            st.pyplot(fig_imp)
            
            # æ˜¾ç¤ºè¯„ä¼°æŒ‡æ ‡
            st.write("### æ¨¡å‹è¯„ä¼°æŒ‡æ ‡")
            metrics = st.session_state.survival_model.train_metrics
            col1, col2, col3 = st.columns(3)
            col1.metric("å¹³å‡ç»å¯¹è¯¯å·® (MAE)", f"{metrics['mae']:.1f} ä¸ªæœˆ")
            col2.metric("å‡æ–¹æ ¹è¯¯å·® (RMSE)", f"{metrics['rmse']:.1f} ä¸ªæœˆ")
            col3.metric("RÂ² åˆ†æ•°", f"{metrics['r2']:.2f}")
        else:
            st.warning("è¯·å…ˆè®­ç»ƒæ¨¡å‹")
    
    # ======================
    # å•æ‚£è€…ç”Ÿå­˜æ—¶é—´é¢„æµ‹
    # ======================
    st.header("ğŸ”® æ‚£è€…ç”Ÿå­˜æ—¶é—´é¢„æµ‹")
    
    with st.form("prediction_form"):
        st.subheader("è¾“å…¥æ‚£è€…ç‰¹å¾è¿›è¡Œç”Ÿå­˜æ—¶é—´é¢„æµ‹")
        
        col1, col2 = st.columns(2)
        with col1:
            age = st.number_input("å¹´é¾„", min_value=30, max_value=85, value=60)
            gender = st.selectbox("æ€§åˆ«", ["ç”·", "å¥³", "male", "female"])
            tnm_options = ['I', 'II', 'III', 'IV']
            tnm_stage = st.selectbox("TNMåˆ†æœŸ", tnm_options, index=2)
        with col2:
            cea_level = st.number_input("CEAæ°´å¹³(ng/mL)", min_value=0.0, max_value=100.0, value=15.0)
            msi_status = st.selectbox("MSIçŠ¶æ€", ["MSS", "MSI-L", "MSI-H"])
            kras_mutation = st.selectbox("KRASçªå˜", ["é˜³æ€§", "é˜´æ€§", "positive", "negative"])
        
        predict_btn = st.form_submit_button("é¢„æµ‹ç”Ÿå­˜æ—¶é—´")
        
        if predict_btn:
            patient_data = {
                'å¹´é¾„': age,
                'æ€§åˆ«': gender,
                'TNMåˆ†æœŸ': tnm_stage,
                'CEAæ°´å¹³(ng/mL)': cea_level,   
                'MSIçŠ¶æ€': msi_status,
                'KRASçªå˜': kras_mutation
            }
            
            prediction, message = st.session_state.survival_model.predict(patient_data)
            
            if prediction is not None:
                # å°†é¢„æµ‹ç»“æœè½¬æ¢ä¸ºå¹´
                years = prediction / 12
                
                st.markdown(f"""
                <div class="prediction-result">
                    <h3>é¢„æµ‹ç”Ÿå­˜æ—¶é—´: {prediction:.1f} ä¸ªæœˆ ({years:.1f} å¹´)</h3>
                    <p><b>ä¸´åºŠå»ºè®®</b>:</p>
                    <ul>
                        <li>æ ¹æ®é¢„æµ‹ç»“æœåˆ¶å®šä¸ªä½“åŒ–éšè®¿è®¡åˆ’</li>
                        <li>ç»“åˆä¸´åºŠåˆ†æœŸå’Œåˆ†å­æ ‡å¿—ç‰©è°ƒæ•´æ²»ç–—æ–¹æ¡ˆ</li>
                        <li>å®šæœŸç›‘æµ‹CEAæ°´å¹³å’Œå½±åƒå­¦å˜åŒ–</li>
                        <li>æä¾›è¥å…»æ”¯æŒå’Œå¿ƒç†è¾…å¯¼</li>
                    </ul>
                </div>
                """, unsafe_allow_html=True)
                
                # è§£é‡Šé¢„æµ‹ç»“æœ
                st.subheader("é¢„æµ‹ç»“æœè§£é‡Š")
                if prediction < 24:
                    st.warning("é¢„æµ‹ç”Ÿå­˜æ—¶é—´è¾ƒçŸ­ï¼ˆ<2å¹´ï¼‰ï¼Œå»ºè®®è€ƒè™‘å¼ºåŒ–æ²»ç–—æ–¹æ¡ˆå’Œå§‘æ¯æ²»ç–—")
                elif prediction < 60:
                    st.info("é¢„æµ‹ç”Ÿå­˜æ—¶é—´ä¸­ç­‰ï¼ˆ2-5å¹´ï¼‰ï¼Œå»ºè®®å®šæœŸéšè®¿å’Œç§¯ææ²»ç–—")
                else:
                    st.success("é¢„æµ‹ç”Ÿå­˜æ—¶é—´è¾ƒé•¿ï¼ˆ>5å¹´ï¼‰ï¼Œé¢„åè¾ƒå¥½ï¼Œå»ºè®®ç»´æŒå½“å‰æ²»ç–—æ–¹æ¡ˆ")
            else:
                st.warning(message)

# ======================
# è¿è¡Œåº”ç”¨
# ======================
if __name__ == "__main__":
    main()
